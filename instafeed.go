package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strconv"
	"strings"
	"time"

	"github.com/Masterminds/goutils"
	"github.com/ahmdrz/goinsta/v2"
	"github.com/gorilla/feeds"
	"github.com/pkg/errors"
)

var (
	insta        *goinsta.Instagram
	configFile   string
	listFile     string
	feedMaxItems int
	showVersion  bool

	version string
)

func init() {
	flag.StringVar(&configFile, "f", path.Join(os.Getenv("HOME"), ".instafeed"),
		"Path to file where to store profile configuration")
	flag.StringVar(&listFile, "l", "", "Path to file containing list of Instagram users")
	flag.BoolVar(&showVersion, "v", false, "Show version and exit")
	flag.IntVar(&feedMaxItems, "n", 20, "Number of user feed items")
	flag.Parse()

	if showVersion {
		fmt.Println("instafeed", version)
		os.Exit(0)
	}
}

func main() {
	var (
		igUsers []string
		items   []*feeds.Item
		err     error
	)

	igUsers = flag.Args()
	if listFile != "" {
		data, err := ioutil.ReadFile(listFile)
		if err != nil {
			dieOnError("unable to read user list file: %s", err)
		}

		igUsers = strings.Split(string(data), "\n")

		if len(igUsers) == 0 {
			dieOnError("no users found in list file")
		}

		// Remove empty item caused by trailing line from file
		if igUsers[len(igUsers)-1] == "" {
			igUsers = igUsers[:len(igUsers)-1]
		}
	}

	igLogin := os.Getenv("IG_LOGIN")
	igPassword := os.Getenv("IG_PASSWORD")

	if igLogin == "" || igPassword == "" {
		dieOnError("IG_LOGIN or IG_PASSWORD environment variable unset")
	}

	if insta, err = goinsta.Import(configFile); err != nil {
		fmt.Fprintf(os.Stderr, "Unable to import Instagram configuration: %s\n", err)
		fmt.Fprintln(os.Stderr, "Attempting new login")

		insta = goinsta.New(igLogin, igPassword)
		if err = insta.Login(); err != nil {
			dieOnError("unable to initialize Instagram client: %s", err)
		}
	}

	if err := insta.Export(configFile); err != nil {
		fmt.Fprintf(os.Stderr, "error: unable to export Instagram client configuration: %s\n", err)
	}

	if len(igUsers) == 0 {
		// If no static list of IG users is provided, attempt retrieving the list of followings
		// from the logged user's account
		for followings := insta.Account.Following(); followings.Next(); {
			for _, u := range followings.Users {
				igUsers = append(igUsers, u.Username)
			}

			if err := followings.Error(); err != nil {
				if err == goinsta.ErrNoMore {
					break
				}

				dieOnError("unable to retrieve followings: %s", err)
			}
		}

		if len(igUsers) == 0 {
			dieOnError("no users provided")
		}
	}

	feed := &feeds.Feed{
		Title:       fmt.Sprintf("Instagram"),
		Link:        &feeds.Link{Href: "https://www.instagram.com/"},
		Description: "Instagram RSS feed generated by Instafeed (https://github.com/falzm/instafeed)",
		Created:     time.Now(),
	}

	for _, u := range igUsers {
		switch {
		case strings.HasPrefix(u, "loc:"):
			id, err := strconv.Atoi(strings.TrimPrefix(u, "loc:"))
			if err != nil {
				dieOnError("invalid location-type value %q", u)
			}

			if items, err = fetchLocationFeedItems(int64(id)); err != nil {
				dieOnError(fmt.Sprintf("unable to retrieve user %q feed: %s", u, err))
			}

		default:
			if items, err = fetchUserFeedItems(u); err != nil {
				dieOnError(fmt.Sprintf("unable to retrieve user %q feed: %s", u, err))
			}
		}

		for _, item := range items {
			feed.Add(item)
		}
	}

	feed.Sort(func(a, b *feeds.Item) bool {
		return a.Created.After(b.Created)
	})

	rss, err := feed.ToRss()
	if err != nil {
		dieOnError("unable to render RSS feed: %s", err)
	}

	fmt.Println(rss)
}

func fetchUserFeedItems(name string) ([]*feeds.Item, error) {
	items := make([]*feeds.Item, 0)

	user, err := insta.Profiles.ByName(name)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get user information")
	}

	latest := user.Feed()
	if err != nil {
		return nil, errors.Wrap(err, "unable to get user latest feed")
	}

	for latest.Next(false) {
		for _, item := range latest.Items {
			items = append(items, formatFeedItem(&item))
			if len(items) >= feedMaxItems {
				return items, nil
			}
		}

		if err := latest.Error(); err != nil {
			if err := latest.Error(); err == goinsta.ErrNoMore {
				break
			}
			return nil, errors.Wrap(err, "unable to retrieve user feed")
		}
	}

	return items, nil
}

func fetchLocationFeedItems(id int64) ([]*feeds.Item, error) {
	section, err := insta.Locations.Feeds(id)
	if err != nil {
		return nil, errors.Wrap(err, "unable to retrieve location feeds")
	}

	items := make([]*feeds.Item, 0)

	for _, l := range section.Sections {
		for _, m := range l.LayoutContent.Medias {
			items = append(items, formatFeedItem(&m.Media))
			if len(items) >= feedMaxItems {
				return items, nil
			}
		}
	}

	return items, nil
}

func formatFeedItem(item *goinsta.Item) *feeds.Item {
	shortDesc, _ := goutils.Abbreviate(item.Caption.Text, 50)

	content := fmt.Sprintf("<p>%s</p>", item.Caption.Text)

	if len(item.Images.Versions) > 0 {
		content += fmt.Sprintf("<p><img src=%q></p>", item.Images.Versions[0].URL)
	}

	if len(item.CarouselMedia) > 0 {
		for _, i := range item.CarouselMedia {
			content += fmt.Sprintf("<p><img src=%q></p>", i.Images.Versions[0].URL)
		}
	}

	return &feeds.Item{
		Id:      item.ID,
		Title:   shortDesc,
		Created: time.Unix(item.TakenAt, 0),
		Author: &feeds.Author{
			Name:  fmt.Sprintf("%s (@%s)", item.User.FullName, item.User.Username),
			Email: item.User.Username + "@instagram.com",
		},
		Description: shortDesc,
		Content:     content,
		Link:        &feeds.Link{Href: fmt.Sprintf("https://www.instagram.com/p/%s", item.Code)},
	}
}

func dieOnError(format string, a ...interface{}) {
	fmt.Fprintf(os.Stderr, fmt.Sprintf("error: %s\n", format), a...)
	os.Exit(1)
}
